{"indice": 121, "title": "Test-driven development \u2013 Wikip\u00e9dia, a enciclop\u00e9dia livre", "url": "https://pt.wikipedia.org/wiki/Test-driven_development", "text": "\n\n\n\nTest-driven development \u2013 Wikip\u00e9dia, a enciclop\u00e9dia livre\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSaltar para o conte\u00fado\n\n\n\n\n\t\tAlternar barra lateral\n\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBusca\n\n\n\n\n\nLinks do usu\u00e1rio\n\n\n\n\nCriar uma conta\n\n\n\n\n\n\n\nFerramentas pessoais\nexpandido\ncollapsed\n\n\nCriar uma conta\nEntrar\n\n\n\t\tP\u00e1ginas para editores conectados saiba mais\n\n\nDiscuss\u00e3oContribui\u00e7\u00f5es\n\n\n\n\n\n\n\n\n\nNavega\u00e7\u00e3o\n\n\nP\u00e1gina principalConte\u00fado destacadoEventos atuaisEsplanadaP\u00e1gina aleat\u00f3riaPortaisInformar um erro\n\n\n\n\nColabora\u00e7\u00e3o\n\n\nBoas-vindasAjudaP\u00e1gina de testesPortal comunit\u00e1rioMudan\u00e7as recentesManuten\u00e7\u00e3oCriar p\u00e1ginaP\u00e1ginas novasContatoDonativos\n\n\n\n\nFerramentas\n\n\nP\u00e1ginas afluentesAltera\u00e7\u00f5es relacionadasCarregar ficheiroP\u00e1ginas especiaisHiperliga\u00e7\u00e3o permanenteInforma\u00e7\u00f5es da p\u00e1ginaCitar esta p\u00e1ginaElemento Wikidata\n\n\n\n\nImprimir/exportar\n\n\nCriar um livroDescarregar como PDFVers\u00e3o para impress\u00e3o\n\n\n\n\n\n\n\n\nEspa\u00e7os nominais\n\n\nArtigoDiscuss\u00e3o\n\n\n\n\n\nVariantes\nexpandido\ncollapsed\n\n\n\n\n\n\n\n\n\nVistas\n\n\nLerEditarEditar c\u00f3digo-fonteVer hist\u00f3rico\n\n\n\n\n\nMais\nexpandido\ncollapsed\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n28 idiomas\nexpandido\ncollapsed\n\n\n\u0627\u0644\u0639\u0631\u0628\u064a\u0629\u0411\u044a\u043b\u0433\u0430\u0440\u0441\u043a\u0438Catal\u00e0\u010ce\u0161tinaDeutsch\u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03acEnglishEspa\u00f1olEesti\u0641\u0627\u0631\u0633\u06ccSuomiFran\u00e7ais\u05e2\u05d1\u05e8\u05d9\u05eaMagyarBahasa IndonesiaItaliano\u65e5\u672c\u8a9eLa .lojban.\ud55c\uad6d\uc5b4NederlandsNorsk bokm\u00e5lPolski\u0420\u0443\u0441\u0441\u043a\u0438\u0439Sloven\u0161\u010dinaSvenska\u0423\u043a\u0440\u0430\u0457\u043d\u0441\u044c\u043a\u0430Ti\u1ebfng Vi\u1ec7t\u4e2d\u6587\nEditar hiperliga\u00e7\u00f5es\n\n\nTest-driven development\n\n\nOrigem: Wikip\u00e9dia, a enciclop\u00e9dia livre.\n\n\n\n\nTest Driven Development (TDD) ou em portugu\u00eas Desenvolvimento guiado por testes \u00e9 uma t\u00e9cnica de desenvolvimento de software que se relaciona com o conceito de verifica\u00e7\u00e3o e valida\u00e7\u00e3o e se baseia em um ciclo curto de repeti\u00e7\u00f5es: Primeiramente o desenvolvedor escreve um caso de teste automatizado que define uma melhoria desejada ou uma nova funcionalidade. Ent\u00e3o, \u00e9 produzido c\u00f3digo que possa ser validado pelo teste para posteriormente o c\u00f3digo ser refatorado para um c\u00f3digo sob padr\u00f5es aceit\u00e1veis. Kent Beck, considerado o criador ou o 'descobridor' da t\u00e9cnica, declarou em 2003 que TDD encoraja designs de c\u00f3digo simples e inspira confian\u00e7a.[1]\nDesenvolvimento dirigido por testes \u00e9 relacionado a conceitos de programa\u00e7\u00e3o de Extreme Programming, iniciado em 1999,[2] mas recentemente tem-se criado maior interesse pela mesma em fun\u00e7\u00e3o de seus pr\u00f3prios ideais.[3]\nAtrav\u00e9s de TDD, programadores podem aplicar o conceito de melhorar e depurar c\u00f3digo legado desenvolvido a partir de t\u00e9cnicas antigas.[4]\n\n\n TDD aplicado ao desenvolvimento de um algoritmo em JavaScript que transforma n\u00fameros romanos em n\u00fameros ordin\u00e1rios\n\u00cdndice\n\n1 Requisitos\n2 Evolu\u00e7\u00e3o hist\u00f3rica\n3 Ciclo de desenvolvimento\n\n3.1 1. Adicione um teste\n3.2 2. Execute todos os testes e veja se algum deles falha\n3.3 3. Escrever c\u00f3digo\n3.4 4. Execute os testes automatizados e veja-os executarem com sucesso\n3.5 5. Refatorar c\u00f3digo\n3.6 6. Repita tudo\n\n\n4 Estilos de desenvolvimento\n5 Benef\u00edcios\n6 Limita\u00e7\u00f5es\n7 Visibilidade de c\u00f3digo\n8 Fakes, mocks e testes de integra\u00e7\u00e3o\n9 Ver tamb\u00e9m\n10 Refer\u00eancias\n11 Notas\n12 Liga\u00e7\u00f5es externas\n\n\nRequisitos[editar | editar c\u00f3digo-fonte]\nDesenvolvimento dirigido por testes[5] requer dos desenvolvedores criar testes automatizados que definam requisitos em c\u00f3digo antes de escrever o c\u00f3digo da aplica\u00e7\u00e3o. Os testes cont\u00e9m asser\u00e7\u00f5es que podem ser verdadeiras ou falsas. Ap\u00f3s as mesmas serem consideradas verdadeiras ap\u00f3s sua execu\u00e7\u00e3o, os testes confirmam o comportamento correto, permitindo os desenvolvedores evoluir e refatorar o c\u00f3digo. Normalmente todos os testes s\u00e3o efetuados de forma continua de acordo com o desenvolvimento cada funcionalidade criada deve ser acompanhada de um teste bem descrito e projetado, ent\u00e3o deve-se escolher a \u00e1rea do projeto ou requisitos da tarefa para melhor orientar o desenvolvimento destes testes.\nDesenvolvedores normalmente usam frameworks de testes, como xUnit, para criar e executar automaticamente uma s\u00e9rie de casos de teste.\n\nEvolu\u00e7\u00e3o hist\u00f3rica[editar | editar c\u00f3digo-fonte]\nKent Beck, considerado o criador ou o descobridor da t\u00e9cnica, declarou em 2003 que TDD encoraja designs de c\u00f3digo simples e inspira confian\u00e7a. Desenvolvimento dirigido por testes \u00e9 relacionado a conceitos de programa\u00e7\u00e3o de Extreme Programming, iniciado em O desenvolvimento guiado por testes, em l\u00edngua inglesa Test Driven Development (TDD), teve origem na metodologia \u00e1gil criado por Kent Beck. Ela se tornou mais conhecida entre desenvolvedores ap\u00f3s a publica\u00e7\u00e3o do livro TDD by exemplo de Kent Beck em 2002. Ainda que utiliza\u00e7\u00e3o j\u00e1 ocorresse h\u00e1 algumas d\u00e9cadas, segundo Larman e Basili (2003), o manifesto \u00e1gil contribuiu muito para impulsion\u00e1-la. pr\u00f3prios ideais. Atrav\u00e9s de TDD, programadores podem aplicar o conceito de melhorar e depurar c\u00f3digo legado desenvolvido a partir de t\u00e9cnicas antigas.\n\nCiclo de desenvolvimento[editar | editar c\u00f3digo-fonte]\n1. Adicione um teste[editar | editar c\u00f3digo-fonte]\nPara escrever um teste, o desenvolvedor precisa claramente entender as especifica\u00e7\u00f5es e requisitos da funcionalidade. O desenvolvedor pode fazer isso atrav\u00e9s de caso de uso que cubram os requisitos e exce\u00e7\u00f5es condicionais. \nEsta \u00e9 a diferencia\u00e7\u00e3o entre desenvolvimento dirigido a testes entre escrever testes de unidade depois do c\u00f3digo desenvolvido. Ele torna o desenvolvedor focado nos requisitos antes do c\u00f3digo, que \u00e9 uma sutil porem importante diferen\u00e7a.\nEm um estudo por George e Willians (2003), com programadores constatou-se que: (87,5%) acreditavam que TDD facilita uma melhor abordagem e compreens\u00e3o dos requisitos; 95,8% acreditavam que o tempo de depura\u00e7\u00e3o foi reduzido; 78% acreditavam que a produtividade do time aumentou; 92% acreditavam que melhorou a qualidade do c\u00f3digo; 79% acreditavam que o design ficou mais simples; e no total 71% acreditavam que a abordagem foi eficaz.\n\n2. Execute todos os testes e veja se algum deles falha[editar | editar c\u00f3digo-fonte]\nEsse passo valida se todos os testes est\u00e3o funcionando corretamente e se o novo teste n\u00e3o traz nenhum equ\u00edvoco, sem requerer nenhum c\u00f3digo novo. Pode-se considerar que este passo ent\u00e3o testa o pr\u00f3prio teste: ele regula a possibilidade de novo teste passar.\nO novo teste deve ent\u00e3o falhar pela raz\u00e3o esperada: a funcionalidade n\u00e3o foi desenvolvida. Isto aumenta a confian\u00e7a (por outro lado n\u00e3o exatamente a garante) que se est\u00e1 testando a coisa certa, e que o teste somente ir\u00e1 passar nos casos intencionados.\n\n3. Escrever c\u00f3digo[editar | editar c\u00f3digo-fonte]\nO pr\u00f3ximo passo \u00e9 escrever c\u00f3digo que ir\u00e1 ocasionar ao teste passar. O novo c\u00f3digo escrito at\u00e9 esse ponto poder\u00e1 n\u00e3o ser perfeito e pode, por exemplo, passar no teste de uma forma n\u00e3o elegante. Isso \u00e9 aceit\u00e1vel porque posteriormente ele ser\u00e1 melhorado.\nO importante \u00e9 que o c\u00f3digo escrito deve ser constru\u00eddo somente para passar no teste; nenhuma funcionalidade (muito menos n\u00e3o testada) deve ser predita ou permitida em qualquer ponto.\n\n4. Execute os testes automatizados e veja-os executarem com sucesso[editar | editar c\u00f3digo-fonte]\nSe todos os testes passam agora, o programador pode ficar confiante de que o c\u00f3digo possui todos os requisitos testados. Este \u00e9 um bom ponto que inicia o passo final do ciclo TDD.\n\n5. Refatorar c\u00f3digo[editar | editar c\u00f3digo-fonte]\nNesse ponto o c\u00f3digo pode ser limpo como necess\u00e1rio. Ao reexecutar os testes, o desenvolvedor pode confiar que a refatora\u00e7\u00e3o n\u00e3o \u00e9 um processo danoso a qualquer funcionalidade existente. Um conceito relevante nesse momento \u00e9 o de remo\u00e7\u00e3o de duplica\u00e7\u00e3o de c\u00f3digo, considerado um importante aspecto ao design de um software. Nesse caso, entretanto, isso aplica remover qualquer duplica\u00e7\u00e3o entre c\u00f3digo de teste e c\u00f3digo de produ\u00e7\u00e3o \u2014 por exemplo magic numbers or strings que n\u00f3s repetimos nos testes e no c\u00f3digo de produ\u00e7\u00e3o, de forma que fa\u00e7a o teste passar no passo 3.\n\n6. Repita tudo[editar | editar c\u00f3digo-fonte]\nIniciando com outro teste, o ciclo \u00e9 ent\u00e3o repetido, empurrando a funcionalidade a frente. O tamanho dos passos deve ser pequeno - t\u00e3o quanto de 1 a 10 edi\u00e7\u00f5es de texto entre cada execu\u00e7\u00e3o de testes. Se novo c\u00f3digo n\u00e3o satisfaz rapidamente um novo teste, ou outros testes falham inesperadamente, o programador deve desfazer ou reverter as altera\u00e7\u00f5es ao inv\u00e9s do uso de excessiva depura\u00e7\u00e3o. A integra\u00e7\u00e3o cont\u00ednua ajuda a prover pontos revers\u00edveis. \u00c9 importante lembrar que ao usar bibliotecas externas n\u00e3o \u00e9 interessante gerar incrementos t\u00e3o pequenos que possam efetivamente testar a biblioteca ,[3] a menos que haja alguma raz\u00e3o para acreditar que a biblioteca tenha defeitos ou n\u00e3o seja suficientemente completada com suas funcionalidades de forma a servir \u00e0s necessidades do programa em que est\u00e1 sendo escrito.\n\nEstilos de desenvolvimento[editar | editar c\u00f3digo-fonte]\nH\u00e1 v\u00e1rios aspectos ao usar desenvolvimento dirigido a testes, por exemplo os princ\u00edpios \"Keep It Simple, Stupid\" (KISS) e \"You Ain`t Gonna Need It\" (YAGNI). Focando em escrever c\u00f3digo somente para os testes passarem, o design do sistema pode ser mais limpo e claro do que o que \u00e9 alcan\u00e7ado por outros m\u00e9todos.[1] Em Test-Driven Developmente By Example Kent Beck sugere o princ\u00edpio \"Fake it, till you make it\".\nPara alcan\u00e7ar altos n\u00edveis conceituais de design (como o uso de Design Pattern), testes s\u00e3o escritos de forma que possam gerar o design. O c\u00f3digo pode acabar permanecendo mais simples do que o padr\u00e3o alvo, entretanto ele deve passar em todos os testes requeridos. Isto pode ser inaceit\u00e1vel de primeira mas ele permite o desenvolvedor focar somente no que \u00e9 importante.\nFalhar primeiro os casos de testes. A ideia \u00e9 garantir que o teste realmente funciona e consegue capturar um erro. Assim que ele \u00e9 mostrado, a funcionalidade almejada pode ser implementada. Isto tem sido apontado como o \"Test-Driven Mantra\", conhecido como vermelho/verde/refatorar onde vermelho significa falhar onde pelo menos uma asser\u00e7\u00e3o falha ,e verde \u00e9 passar, que significa que todas as asser\u00e7\u00f5es foram verdadeiras.\nDesenvolvimento dirigido a testes constantemente repete os passos de adicionar casos de teste que falham, passando e refatorando-os. Ao receber o resultado esperado em cada est\u00e1gio refor\u00e7a ao desenvolvedor o modelo mental do c\u00f3digo, aumentando a confian\u00e7a e incrementando a produtividade.\nPr\u00e1ticas avan\u00e7adas de desenvolvimento dirigido a testes encaminham para o desenvolvimento dirigido a testes de aceita\u00e7\u00e3o (ATDD), onde o crit\u00e9rio especificado pelo cliente \u00e9 automatizado em testes de aceita\u00e7\u00e3o, que ent\u00e3o levam ao tradicional processo de desenvolvimento dirigido a testes de unidade. Este processo garante que o cliente tem um mecanismo automatizado para decidir como o software atende suas necessidades. Com ATDD, o desenvolvimento em equipe tem objetivo espec\u00edfico para satisfazer, e os testes de aceita\u00e7\u00e3o os mant\u00e9m continuamente focados em o que o cliente realmente deseja daquela funcionalidade.\n\nBenef\u00edcios[editar | editar c\u00f3digo-fonte]\nUm estudo de 2005 descobriu que usar TDD significava escrever mais testes, e logo, programadores que escreviam mais testes tendiam a ser mais produtivos.[6] Hip\u00f3teses relacionando a qualidade de c\u00f3digo e uma correla\u00e7\u00e3o direta entre TDD e produtividade foram inconclusivas.[7]\nDesenvolvedores usando TDD puramente em novos projetos reportaram que raramente necessitaram a utiliza\u00e7\u00e3o de um depurador. Usado em jun\u00e7\u00e3o com um Sistema de controle de vers\u00e3o, quando testes falham inesperadamente, reverter o c\u00f3digo para a \u00faltima vers\u00e3o em que os testes passaram pode ser mais produtivo do que depurar.[8][9]\nDesenvolvimento dirigido por testes oferece mais do que somente um maneira simples de valida\u00e7\u00e3o e de corre\u00e7\u00e3o, pode orientar o design de um programa. Por focar em casos de testes primeiramente, deve-se imaginar como a funcionalidade ser\u00e1 usada pelo cliente. Logo, o programador \u00e9 somente com a interface e n\u00e3o com a implementa\u00e7\u00e3o. Este benef\u00edcio \u00e9 complementar ao Design por Contrato, que atrav\u00e9s torna os casos de testes muito mais do que asser\u00e7\u00f5es matem\u00e1ticas ou pr\u00e9-concep\u00e7\u00f5es.\nO poder que TDD oferece \u00e9 a habilidade de pegar pequenas partes quando requeridas. Isso permite o desenvolvedor focar como objetivo fazer os testes atuais passarem. Casos excepcionais e tratamento de erros n\u00e3o s\u00e3o considerados inicialmente. Testes que criam estas circunst\u00e2ncias estranhas s\u00e3o implementadas separadamente. Outra vantagem \u00e9 que TDD quando usado apropriadamente, garante que todo o c\u00f3digo desenvolvido seja coberto por um teste. Isto fornece a equipe de desenvolvimento, e ao usu\u00e1rios, subsequentemente, um grande n\u00edvel de confian\u00e7a ao c\u00f3digo.\nEnquanto que \u00e9 verdade que mais c\u00f3digo \u00e9 necess\u00e1rio ao usar TDD do que sem TDD, devido aos c\u00f3digos de teste, o tempo total de implementa\u00e7\u00e3o \u00e9 tipicamente menor.[10] Um grande n\u00famero de testes ajudam a limitar o n\u00famero de defeitos no c\u00f3digo. A natureza peri\u00f3dica ajuda a capturar defeitos inicialmente no ciclo de desenvolvimento, prevenindo-os de se tornarem grandes e end\u00eamicos problemas. Eliminando defeitos cedo no processo normalmente evita longos e tediantes per\u00edodos de depura\u00e7\u00e3o posteriores em um projeto.\nTDD pode encaminhar a um n\u00edvel que possibilite um c\u00f3digo mais modularizado, flex\u00edvel e extens\u00edvel. Este efeito surge devido a metodologia requerer que os desenvolvedores pensem no software em pequenas unidades que podem ser reescritas, desenvolvidas e testadas independentemente e integradas depois. Isto implica menores e mais classes, evitando o acoplamento e permitindo interfaces mais limpas. O uso de Mock Object \u00e9 um contribuidor para a modulariza\u00e7\u00e3o do c\u00f3digo, pois este recurso requer que o c\u00f3digo seja escrito de forma que possa ser facilmente trocado entre vers\u00f5es Mock, usados em testes de unidade, e \"reais\", usados na aplica\u00e7\u00e3o.\nDevido a fato de que nenhum c\u00f3digo \u00e9 escrito a n\u00e3o ser para passar em um teste que esteja falhando, testes automatizados tendem a cobrir cada caminho de c\u00f3digo. Por exemplo, para que um desenvolvedor possa adicionar um caminho alternativo \"sen\u00e3o\" em um \"se\" , o desenvolvedor poderia primeiramente escrever um teste que motive o fluxo alternativo. Como resultado, os testes automatizados TDD tendem a ser mais perfeitos: eles ir\u00e3o mostrar qualquer mudan\u00e7a inesperada no comportamento do c\u00f3digo. Isto ajuda a identificar problemas cedo que poderiam aparecer ao consertar uma funcionalidade que ao modificada, inesperadamente altera outra funcionalidade.\n\nLimita\u00e7\u00f5es[editar | editar c\u00f3digo-fonte]\nDesenvolvimento dirigido com testes \u00e9 dif\u00edcil de usar em situa\u00e7\u00f5es onde testes totalmente funcionais s\u00e3o requeridos para determinar o sucesso ou falha. Exemplos disso s\u00e3o interfaces de usu\u00e1rios, programas que trabalham com base de dados, e muitos  outros que dependem de configura\u00e7\u00f5es espec\u00edficas de rede. TDD encoraja os desenvolvedores a incluir o m\u00ednimo de c\u00f3digo funcional em m\u00f3dulos e maximizar a l\u00f3gica, que \u00e9 extra\u00edda em c\u00f3digo de teste, usando Fakes mocks para representar o mundo externo.\nSuporte gerencial \u00e9 essencial. Se toda a organiza\u00e7\u00e3o n\u00e3o acreditar que TDD \u00e9 para melhorar o produto, o gerenciamento ir\u00e1 considerar que o tempo gasto escrevendo teste \u00e9 desperd\u00edcio.[11]\nOs pr\u00f3prios testes se tornam parte da manuten\u00e7\u00e3o do projeto. Testes mal escritos, por exemplo, que incluem strings de erro embutidas ou aqueles que s\u00e3o sucept\u00edveis a falha, s\u00e3o caros de manter. H\u00e1 um risco em testes que geram falsas falhas de tenderem a serem ignorados. Assim quando uma falha real ocorre, ela pode n\u00e3o ser detectada. \u00c9 poss\u00edvel escrever testes de baixa e f\u00e1cil manuten\u00e7\u00e3o, por exemplo pelo reuso das strings de erro, podendo ser o objetivo durante a fase de refatora\u00e7\u00e3o descrita acima.\nO n\u00edvel de cobertura e detalhamento de teste alcan\u00e7ado durante repetitivos ciclos de TDD n\u00e3o pode ser facilmente recriado em uma data tardia. Com o passar do tempo os testes v\u00e3o se tornando gradativamente preciosos. Se uma arquitetura pobre, um mal design ou uma estrat\u00e9gia de teste mal feita acarretar em mudan\u00e7a tardia, fazendo com que dezenas de testes falhem, por outro lado eles s\u00e3o individualmente consert\u00e1veis. Entretanto, simplesmente deletando, desabilitando ou alterando-os vagamente poder\u00e1 criar buracos indetect\u00e1veis na cobertura de testes.\nLacunas inesperadas na cobertura de teste podem existir ou ocorrer por uma s\u00e9rie de raz\u00f5es. Talvez um ou mais desenvolvedores em uma equipe n\u00e3o foram submetidos ao uso de TDD e n\u00e3o escrevem testes apropriadamente, talvez muitos conjuntos de testes foram invalidados, exclu\u00eddos ou desabilitados acidentalmente ou com o intuito de melhor\u00e1-los posteriormente. Se isso acontece, a certeza \u00e9 de que um enorme conjunto de testes TDD ser\u00e3o corrigidos tardiamente e refatora\u00e7\u00f5es ser\u00e3o mal acopladas. Altera\u00e7\u00f5es podem ser feitas n\u00e3o resultando em falhas, entretanto, na verdade, bugs est\u00e3o sendo introduzidos imperceptivelmente, permanecendo indetect\u00e1veis.\nTestes de unidade criados em um ambiente de desenvolvimento dirigido por testes s\u00e3o tipicamente criados pelo desenvolvedor que ir\u00e1 ent\u00e3o escrever o c\u00f3digo que est\u00e1 sendo testado. Os testes podem consequentemente compartilhar os 'pontos cegos' no c\u00f3digo: Se por exemplo, um desenvolvedor n\u00e3o realizar determinadas entradas de par\u00e2metros que precisam ser checadas, muito provavelmente nem o teste nem o c\u00f3digo ir\u00e1 verificar essas entradas. Logo, se o desenvolvedor interpreta mal a especifica\u00e7\u00e3o dos requisitos para o m\u00f3dulo que est\u00e1 sendo desenvolvido, tanto os testes como o c\u00f3digo estar\u00e3o errados.\nO alto n\u00famero de testes de unidades pode trazer um falso senso de seguran\u00e7a, resultando em menor n\u00edvel de atividades de garantia de qualidade, como testes de integra\u00e7\u00e3o e aceita\u00e7\u00e3o.\nVisibilidade de c\u00f3digo[editar | editar c\u00f3digo-fonte]\nO conjunto de teste claramente possibilita acessar o c\u00f3digo que est\u00e1 se testando. Por outro lado crit\u00e9rios normais de design como Information hiding, encapsulamento e separa\u00e7\u00e3o de conceitos n\u00e3o devem ser comprometidos. Consequentemente teste de unidade s\u00e3o normalmente escritos no mesmo projeto ou  m\u00f3dulo que o c\u00f3digo est\u00e1 sendo testado.\nAo usar design orientado a objetos, este n\u00e3o prov\u00ea acesso ao m\u00e9todos e dados privados. Consequentemente, trabalho extra pode ser necess\u00e1rio para testes de unidade. Em Java e outras liguagens, um desenvolvedor pode usar reflex\u00e3o para acessar campos que s\u00e3o marcados como privados.[12]\nAlternativamente, uma classe inerente pode ser usada para suportar os testes de unidade, assim tendo visibilidade dos membros e atributos da classe. No .NET e em muitas outras linguagens, classes parciais podem ser usadas para expor m\u00e9todos privados e dados para os testes acessarem.\nO importante \u00e9 que modifica\u00e7\u00f5es brutas no testes n\u00e3o apare\u00e7am no c\u00f3digo de produ\u00e7\u00e3o. Em C# e em outras linguagens, diretivas de de pr\u00e9-compila\u00e7\u00e3o como #if DEBUG ... #endif pode ser posicionadas em volta de classes adicionais e realmente prevenir todos os outros c\u00f3digos relacionados a teste de serem compilados no c\u00f3digo de lan\u00e7amento. Isto ent\u00e3o significa que o c\u00f3digo lan\u00e7ado n\u00e3o \u00e9 exatamente o mesmo de quando testado. A execu\u00e7\u00e3o regular de poucos mais completos,  testes de integra\u00e7\u00e3o de aceita\u00e7\u00e3o ao final do lan\u00e7amento do c\u00f3digo podem garantir que n\u00e3o existe c\u00f3digo de produ\u00e7\u00e3o que subitamente dependa dos testes.\nH\u00e1 muito debate entre os praticantes de TDD, documentados nos seus blogs e outros locais, com a d\u00favida se \u00e9 de bom julgamento testar m\u00e9todos privados e protegidos e dados de qualquer maneira. Muitos argumentam que poderia ser suficiente testar qualquer classe atrav\u00e9s da interface p\u00fablica, considerando membros privados como meramente detalhes de implementa\u00e7\u00f5es que podem mudar, e se deveria ser permitido fazer sem quebrar nenhum teste. Outros dizem que aspectos cruciais de uma funcionalidade podem ser implementados em m\u00e9todos privados, e que ao fazer desta forma eles s\u00e3o indiretamente testados atrav\u00e9s da interface p\u00fablica obscurecendo a ocorr\u00eancia dos mesmos: Testes de unidade s\u00e3o para testar a menor unidade de funcionalidade poss\u00edvel.[13][14]\n\nFakes, mocks e testes de integra\u00e7\u00e3o[editar | editar c\u00f3digo-fonte]\nTestes de unidades s\u00e3o assim chamados por cada teste exercitar uma unidade de c\u00f3digo. Se um m\u00f3dulo tem centenas de testes de unidade ou somente cinco \u00e9 irrelevante. Um conjunto de testes em TDD nunca cruza os limites de um programa, nem deixa conex\u00f5es de rede perdidas. Ao fazer essas a\u00e7\u00f5es, o mesmo introduz intervalos de tempo que podem tornar testes lentos ao serem executados, desencorajando desenvolvedores de executar toda a suite de testes. Introduzir depend\u00eancias de m\u00f3dulos externos ou data transforma teste de unidade em testes de integra\u00e7\u00e3o. Se um m\u00f3dulo se comporta mal em uma cadeia de m\u00f3dulos interrelacionados, n\u00e3o fica imediatamente claro onde olhar a causa da falha.\nQuando o c\u00f3digo em desenvolvimento depende confiavelmente de uma base de dados, um servi\u00e7o web ou qualquer outro processo externo ou servi\u00e7o, obrigando em um separa\u00e7\u00e3o unit\u00e1ria de teste \u00e9 ent\u00e3o uma oportunidade for\u00e7ada de criar um design de c\u00f3digo mais modular, mais test\u00e1vel e reus\u00e1vel.[15] Dois passos s\u00e3o necess\u00e1rios:\n\nToda vez que um acesso externo \u00e9 necess\u00e1rio no design final, uma interface deve ser definida de forma a descrever que acessos ir\u00e3o ser dispon\u00edveis. O princ\u00edpio de invers\u00e3o de depend\u00eancia fornece benef\u00edcios nessa situa\u00e7\u00e3o em TDD.\nA interface deve ser implementada de duas maneiras, uma que realmente acessa o processo externo, e outra que \u00e9 um fake ou mock. Objetos fake precisam fazer um pouco mais do que adicionar mensagens \"Objeto Pessoa salvo\" criando registro de rastreio, identificando que asser\u00e7\u00f5es podem executadas para verificar o comportamento correto. Objetos mock diferem pelo fato que eles mesmos cont\u00e9m asser\u00e7\u00f5es que podem fazer com que o teste falhe. Exemplo:\nSe o nome da pessoa e outro dado n\u00e3o \u00e9 como esperado. m\u00e9todos de objetos fake e mock que retornem dados, aparentemente de uma armazenamento de dados ou de usu\u00e1rio,pode ajudar ao processo de teste sempre retornar o mesmo, dados que testes pode confiar. Eles podem ser muito us\u00e1veis em predefinidos modos de falha em que rotinas de tratamento de erro pode ser desenvolvidas e confiavelmente testadas. Servi\u00e7os fake dentre outros armazenamento de dados podem ser us\u00e1veis em TDD: um servi\u00e7o fake de criptografia pode n\u00e3o, criptografar o dado passado;[necess\u00e1rio esclarecer] servi\u00e7os fake de n\u00famero aleat\u00f3rio podem sempre retornar 1. Implementa\u00e7\u00f5es de fakes e mocks s\u00e3o exemplos de inje\u00e7\u00e3o de depend\u00eancia.\nA proposta da inje\u00e7\u00e3o de depend\u00eancia \u00e9 que a base de dados ou qualquer ou c\u00f3digo de acesso externo nunca \u00e9 testado pelo processo TDD. Para desviar de erros que possam aparecer em fun\u00e7\u00e3o disso, outros testes com a real implementa\u00e7\u00e3o das interfaces discutidas acima s\u00e3o necess\u00e1rios. Esses testes s\u00e3o separados dos testes unit\u00e1rios e s\u00e3o realmente testes de integra\u00e7\u00e3o. Eles ser\u00e3o poucos, e eles precisam ser menos executados os testes de unidades. Eles podem ser implementados sem nenhum problema usando o mesmo framework de testes, como xUnit .\nTestes de integra\u00e7\u00e3o que alteram qualquer armazenamento persistente ou banco de dados deve ser designado cuidadosamente, levando em considera\u00e7\u00e3o os estados iniciais e finais dos arquivos e base de dados, independente se um teste falha. Isto \u00e9 muitas vezes adquirido usando v\u00e1rias combina\u00e7\u00f5es das seguintes t\u00e9cnicas:\n\nO m\u00e9todo TearDown, que \u00e9 integrado ao muitos frameworks de teste.\nEstruturas try...catch...finally de tratamento de exce\u00e7\u00f5es, quando dispon\u00edveis.\nTransa\u00e7\u00f5es de banco de dados onde ela atomicamente inclui talvez um escrita, uma leitura e uma opera\u00e7\u00e3o de dele\u00e7\u00e3o.\nCapturando o \"estado\" do banco de dados antes de executar qualquer teste e ap\u00f3s a execu\u00e7\u00e3o, desfasar para o \"estado\" antes do teste ser executado. Isso pode ser automatizado usando a framework como o Ant ou NAnt ou um sistema de integra\u00e7\u00e3o cont\u00ednua como o CruiseControl.\nInicializando o banco de dados para um estado limpo antes dos testes, ao inv\u00e9s de limpar depois da execu\u00e7\u00e3o dos testes. Isto pode ser relevante onde limpar depois pode tornar dif\u00edcil de diagnosticar falhas de teste ao deletar o estado final do banco de dados antes que um diagn\u00f3tico detalhado possa ser feito.\nFramework como Moq, jMock, NMock, EasyMock, TypeMock, jMockit, Mockito, PowerMock e Rhino Mocks existem para tornar o processo de criar e usar objetos mock complexos facilmente.\n\nVer tamb\u00e9m[editar | editar c\u00f3digo-fonte]\n\n\n\n\nA Wikip\u00e9dia tem o portal:Teste de Software\n\n\nAegis um sistema de gerenciamento de mudan\u00e7as de software que suporta um fluxo de trabalho de desenvolvimento de software dirigido por teste .\nBehavior Driven Development\nDesign por contrato\nLista de filosofias de desenvolvimento de software\nLista de frameworks de teste unit\u00e1rio\nObjeto mock\nTeste de software\nCaso de teste\nTeste unit\u00e1rio\nDesenvolvimento \u00e1gil software\nRefer\u00eancias[editar | editar c\u00f3digo-fonte]\n\n\n\u2191 a b Beck, K. Test-Driven Development by Example, Addison Wesley - Vaseem, 2003\n\n\u2191 \n  \"Extreme Programming\", Computerworld (online),\n  December 2001, webpage:\nComputerworld-appdev-92.\n\n\u2191 a b Newkirk, JW and Vorontsov, AA. Test-Driven Development in Microsoft .NET, Microsoft Press, 2004.\n\n\u2191 Feathers, M. Working Effectively with Legacy Code, Prentice Hall, 2004\n\n\u2191 \u00abWhat is TDD? Everything About Test Driven Development\u00bb. Insights on Latest Technologies - Simform Blog (em ingl\u00eas). 15 de abril de 2019. Consultado em 27 de agosto de 2021\u00a0\n\n\u2191 \nErdogmus, Hakan; Morisio, Torchiano. \u00abOn the Effectiveness of Test-first Approach to Programming\u00bb. Proceedings of the IEEE Transactions on Software Engineering, 31(1). January 2005. (NRC 47445). Consultado em 14 de janeiro de 2008. Arquivado do original em 27 de agosto de 2011. We found that test-first students on average wrote more tests and, in turn, students who wrote more tests tended to be more productive.\u00a0 A refer\u00eancia emprega par\u00e2metros obsoletos |coautor= (ajuda)\n\n\u2191 \nProffitt, Jacob. \u00abTDD Proven Effective! Or is it?\u00bb. Consultado em 21 de fevereiro de 2008. Arquivado do original em 27 de agosto de 2011. So TDD's relationship to quality is problematic at best. Its relationship to productivity is more interesting. I hope there's a follow-up study because the productivity numbers simply don't add up very well to me. There is an undeniable correlation between productivity and the number of tests, but that correlation is actually stronger in the non-TDD group (which had a single outlier compared to roughly half of the TDD group being outside the 95% band).\u00a0\n\n\u2191 Clark, Mike. \u00abTest-Driven Development with JUnit Workshop\u00bb. Clarkware Consulting, Inc. Consultado em 1 de novembro de 2007. In fact, test-driven development actually helps you meet your deadlines by eliminating debugging time, minimizing design speculation and re-work, and reducing the cost and fear of changing working code.\u00a0\n\n\u2191 \nLlopis, Noel (20 de fevereiro de 2005). \u00abStepping Through the Looking Glass: Test-Driven Game Development (Part 1)\u00bb. Games from Within. Consultado em 1 de novembro de 2007. Arquivado do original em 13 de outubro de 2007. Comparing [TDD] to the non-test-driven development approach, you're replacing all the mental checking and debugger stepping with code that verifies that your program does exactly what you intended it to do.\u00a0\n\n\u2191 M\u00fcller, Matthias M.; Padberg, Frank. \u00abAbout the Return on Investment of Test-Driven Development\u00bb (PDF). Universit\u00e4t Karlsruhe, Germany. 6\u00a0p\u00e1ginas. Consultado em 1 de novembro de 2007\u00a0 A refer\u00eancia emprega par\u00e2metros obsoletos |coautor= (ajuda)\n\n\u2191 Loughran, Steve (November 6th, 2006). \u00abTesting\u00bb (PDF). HP Laboratories. Consultado em 12 de agosto de 2009\u00a0 Verifique data em: |data= (ajuda)\n\n\u2191 Burton, Ross (11 de dezembro de 2003). \u00abSubverting Java Access Protection for Unit Testing\u00bb. O'Reilly Media, Inc. Consultado em 12 de agosto de 2009\u00a0\n\n\u2191 Newkirk, James (7 de junho de 2004). \u00abTesting Private Methods/Member Variables - Should you or shouldn't you\u00bb. Microsoft Corporation. Consultado em 12 de agosto de 2009\u00a0\n\n\u2191 Stall, Tim (1 de mar\u00e7o de 2005). \u00abHow to Test Private and Protected methods in .NET\u00bb. CodeProject. Consultado em 12 de agosto de 2009\u00a0\n\n\u2191 Fowler, Martin (1999). Refactoring - Improving the design of existing code. Boston: Addison Wesley Longman, Inc. ISBN\u00a00-201-48567-2\u00a0\n\n\nNotas[editar | editar c\u00f3digo-fonte]\nEste artigo foi inicialmente traduzido do artigo da Wikip\u00e9dia em ingl\u00eas, cujo t\u00edtulo \u00e9 \u00abTest Driven Development\u00bb.\nLiga\u00e7\u00f5es externas[editar | editar c\u00f3digo-fonte]\nc2.com Test-driven development from WikiWikiWeb\nTest or spec? Test and spec? Test from spec!, by Bertrand Meyer (September 2004)\nMicrosoft Visual Studio Team Test from a TDD approach\nWrite Maintainable Unit Tests That Will Save You Time And Tears\nTDD gen\u00e9rico que funciona em qualquer ferramenta existente\nhttps://tdd.caelum.com.br/\n\n\n\n\n\n\nObtida de \"https://pt.wikipedia.org/w/index.php?title=Test-driven_development&oldid=61925752\"\nCategorias: Processo de desenvolvimento de softwareTeste de softwareCategorias ocultas: !CS1 ingl\u00eas-fontes em l\u00edngua (en)!P\u00e1ginas que usam refer\u00eancias com par\u00e2metros obsoletas!P\u00e1ginas com erros CS1: datas!Artigos que necessitam de esclarecimento\n\n\n\n\n\n\n\n\n\n\n\n Esta p\u00e1gina foi editada pela \u00faltima vez \u00e0s 09h40min de 27 de agosto de 2021.\nEste texto \u00e9 disponibilizado nos termos da licen\u00e7a Atribui\u00e7\u00e3o-CompartilhaIgual 3.0 N\u00e3o Adaptada (CC BY-SA 3.0) da Creative Commons;\npode estar sujeito a condi\u00e7\u00f5es adicionais.\nPara mais detalhes, consulte as condi\u00e7\u00f5es de utiliza\u00e7\u00e3o.\n\n\nPol\u00edtica de privacidade\nSobre a Wikip\u00e9dia\nAvisos gerais\nVers\u00e3o m\u00f3vel\nProgramadores\nEstat\u00edsticas\nDeclara\u00e7\u00e3o sobre ''cookies''\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "encoding": "utf-8"}